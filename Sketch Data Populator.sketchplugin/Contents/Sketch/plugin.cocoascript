//===============================================
// sketch data populator - plugin
//===============================================

@import 'lodash.get.cocoascript';
@import 'library.cocoascript';
@import 'sandbox.cocoascript';


//store global context reference
var context;
var selection;

function populateWithPresetHandler(_context) {
	context = _context;

	//get user defaults
	var defaults = [NSUserDefaults standardUserDefaults];

	//load presets
	var presets = Library.loadPresets();
	if(!presets.length) {
		context.document.showMessage('There are no Presets.');
		return;
	}

	//get selected layers
	var selectedLayers = Library.getSelectedLayers();
	selection = selectedLayers;
	if(!selectedLayers.length) {
		context.document.showMessage('Please select the layers you would like to populate.');
		return;
	}

	//get preset names array
	var presetNames = [];
	presets.forEach(function(preset) {
		presetNames.push(preset.name);
	});

	//create alert
	var alert = Library.createAlert("Populate with Preset", "Please select the Preset you'd like to use to populate your design and configure the options.", "icon.png");

	//create list view
	var listView = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 50)];
	[alert addAccessoryView: listView];

	//create preset list title
	var presetListTitle = Library.createLabel('Select Preset', 12, true, NSMakeRect(0, 30, 300, 20));
	[listView addSubview: presetListTitle];

	//create preset list
	var presetList = Library.createSelect(presetNames, 0, NSMakeRect(0, 0, 300, 25)];
	[listView addSubview: presetList];

	//select last selected preset
	var lastSelectedPresetIndex = [defaults objectForKey:'selectedPresetIndex'];
	if(lastSelectedPresetIndex && lastSelectedPresetIndex < presetNames.length) {
		[presetList selectItemAtIndex: lastSelectedPresetIndex];
	}

	//add space
	var spacerView = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 5)];
	[alert addAccessoryView: spacerView];

	//create data options view
	var dataOptionsView = createDataOptionsView();
	[alert addAccessoryView: dataOptionsView.view];

	//add space
	var spacerView2 = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 5)];
	[alert addAccessoryView: spacerView2];

	//create layout options view
	var layoutOptionsView = createLayoutOptionsView();
	[alert addAccessoryView: layoutOptionsView.view];

	//add bottom buttons
	[alert addButtonWithTitle:"Populate"];
	[alert addButtonWithTitle:"Cancel"];

	//set rows textfield as first responder
	var alertWindow = [[alert alert] window];
	[alertWindow setInitialFirstResponder: layoutOptionsView.rowsCountTextField];
	[alertWindow setAutorecalculatesKeyViewLoop: true];

	//show alert
	var responseCode = [alert runModal];
	if(responseCode == '1000') {

		//get selected preset index
		var selectedPresetIndex = [presetList indexOfSelectedItem];

		//get preset paths
		var presetPath = [NSString stringWithString: presets[selectedPresetIndex].path];
		var presetParentDir = [presetPath stringByDeletingLastPathComponent];

		//== data options =======================

		//get randomize checkbox state
		var randomizeCheckbox = dataOptionsView.randomizeCheckbox;
		var randomizeData = Number([randomizeCheckbox state]);

		//get trim checkbox state
		var trimCheckbox = dataOptionsView.trimCheckbox;
		var trimText = Number([trimCheckbox state]);

		//get ellipsis checkbox state
		var ellipsisCheckbox = dataOptionsView.ellipsisCheckbox;
		var insertEllipsis = Number([ellipsisCheckbox state]);

		//get default substitute
		var substituteTextField = dataOptionsView.substituteTextField;
		var defaultSubstitute = [substituteTextField stringValue];

		//== layout options =====================

		//get create grid checkbox state
		var createGridCheckbox = layoutOptionsView.createGridCheckbox;
		var isCreateGrid = Number([createGridCheckbox state]);

		//get grid config
		var rowsCountTextField = layoutOptionsView.rowsCountTextField;
		var rowsCount = Number([rowsCountTextField stringValue].split(/[\.\,]/g)[0]);
		var rowsMarginTextField = layoutOptionsView.rowsMarginTextField;
		var rowsMargin = Number([rowsMarginTextField stringValue].replace(/\,/g, '.'));
		var columnsCountTextField = layoutOptionsView.columnsCountTextField;
		var columnsCount = Number([columnsCountTextField stringValue].split(/[\.\,]/g)[0]);
		var columnsMarginTextField = layoutOptionsView.columnsMarginTextField;
		var columnsMargin = Number([columnsMarginTextField stringValue].replace(/\,/g, '.'));

		//save data options
		[defaults setObject: selectedPresetIndex forKey: 'selectedPresetIndex'];
		[defaults setObject: presetPath forKey: 'dataPath'];
		[defaults setObject: 'preset' forKey: 'populateMethod'];
		[defaults setObject: randomizeData forKey: 'randomizeData'];
		[defaults setObject: trimText forKey: 'trimText'];
		[defaults setObject: insertEllipsis forKey: 'insertEllipsis'];
		[defaults setObject: defaultSubstitute forKey: 'defaultSubstitute'];

		//save layout options
		[defaults setObject: isCreateGrid forKey: 'createGrid'];
		[defaults setObject: rowsCount forKey: 'rowsCount'];
		[defaults setObject: rowsMargin forKey: 'rowsMargin'];
		[defaults setObject: columnsCount forKey: 'columnsCount'];
		[defaults setObject: columnsMargin forKey: 'columnsMargin'];

		//sync defaults
		[defaults synchronize];

		//load data
		var presetData = loadData(presetPath);

		//create grid
		if(isCreateGrid) {
			selectedLayers = createGrid(selectedLayers, {
				rowsCount: rowsCount,
				rowsMargin: rowsMargin,
				columnsCount: columnsCount,
				columnsMargin: columnsMargin
			});
			selection = selectedLayers;

			//make sure that grid creation was successful
			if(!selectedLayers) {
				return;
			}
		}

		//populate design with data
		populate(presetData, selectedLayers, {
			rootDir: presetParentDir,
			randomizeData: randomizeData,
			trimText: trimText,
			insertEllipsis: insertEllipsis,
			defaultSubstitute: defaultSubstitute
		});
	}
}


function populateWithJSONHandler(_context) {
	context = _context;

	//get user defaults
	var defaults = [NSUserDefaults standardUserDefaults];

	//get selected layers
	var selectedLayers = Library.getSelectedLayers();
	selection = selectedLayers;
	if(!selectedLayers.length) {
		context.document.showMessage('Please select the layers you would like to populate.');
		return;
	}

	//get last used location
	var defaults = [NSUserDefaults standardUserDefaults];
	var lastLocation = [defaults objectForKey: 'LastJSONFilePickerLocation'];

	//get JSON file path
	var filePath = Library.askForJSON(lastLocation);
	if(!filePath) return;

	//save last used location
	[defaults setObject: filePath forKey: 'LastJSONFilePickerLocation'];
	[defaults synchronize];

	//get root dir
	var rootDir = [filePath stringByDeletingLastPathComponent];
	if(!Sandbox.authoriseDir(rootDir)) return;

	//create alert
	var alert = Library.createAlert("Populate with JSON", "Please configure the options below.", "icon.png");

	//create data options view
	var dataOptionsView = createDataOptionsView();
	[alert addAccessoryView: dataOptionsView.view];

		//add space
	var spacerView2 = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 5)];
	[alert addAccessoryView: spacerView2];

	//create layout options view
	var layoutOptionsView = createLayoutOptionsView();
	[alert addAccessoryView: layoutOptionsView.view];

	//add bottom buttons
	[alert addButtonWithTitle:"Populate"];
	[alert addButtonWithTitle:"Cancel"];

	//set rows textfield as first responder
	var alertWindow = [[alert alert] window];
	[alertWindow setInitialFirstResponder: layoutOptionsView.rowsCountTextField];
	[alertWindow setAutorecalculatesKeyViewLoop: true];

	//show alert
	var responseCode = [alert runModal];
	if(responseCode == '1000') {

		//== data options =======================

		//get randomize checkbox state
		var randomizeCheckbox = dataOptionsView.randomizeCheckbox;
		var randomizeData = Number([randomizeCheckbox state]);

		//get trim checkbox state
		var trimCheckbox = dataOptionsView.trimCheckbox;
		var trimText = Number([trimCheckbox state]);

		//get ellipsis checkbox state
		var ellipsisCheckbox = dataOptionsView.ellipsisCheckbox;
		var insertEllipsis = Number([ellipsisCheckbox state]);

		//get default substitute
		var substituteTextField = dataOptionsView.substituteTextField;
		var defaultSubstitute = [substituteTextField stringValue];

		//== layout options =====================

		//get create grid checkbox state
		var createGridCheckbox = layoutOptionsView.createGridCheckbox;
		var isCreateGrid = Number([createGridCheckbox state]);

		//get grid config
		var rowsCountTextField = layoutOptionsView.rowsCountTextField;
		var rowsCount = Number([rowsCountTextField stringValue].split(/[\.\,]/g)[0]);
		var rowsMarginTextField = layoutOptionsView.rowsMarginTextField;
		var rowsMargin = Number([rowsMarginTextField stringValue].replace(/\,/g, '.'));
		var columnsCountTextField = layoutOptionsView.columnsCountTextField;
		var columnsCount = Number([columnsCountTextField stringValue].split(/[\.\,]/g)[0]);
		var columnsMarginTextField = layoutOptionsView.columnsMarginTextField;
		var columnsMargin = Number([columnsMarginTextField stringValue].replace(/\,/g, '.'));

		//save data options
		[defaults setObject: filePath forKey: 'dataPath'];
		[defaults setObject: 'JSON' forKey: 'populateMethod'];
		[defaults setObject: randomizeData forKey: 'randomizeData'];
		[defaults setObject: trimText forKey: 'trimText'];
		[defaults setObject: insertEllipsis forKey: 'insertEllipsis'];
		[defaults setObject: defaultSubstitute forKey: 'defaultSubstitute'];

		//save layout options
		[defaults setObject: isCreateGrid forKey: 'createGrid'];
		[defaults setObject: rowsCount forKey: 'rowsCount'];
		[defaults setObject: rowsMargin forKey: 'rowsMargin'];
		[defaults setObject: columnsCount forKey: 'columnsCount'];
		[defaults setObject: columnsMargin forKey: 'columnsMargin'];

		//sync defaults
		[defaults synchronize];

		//load data
		var data = loadData(filePath);

		//create grid
		if(isCreateGrid) {
			selectedLayers = createGrid(selectedLayers, {
				rowsCount: rowsCount,
				rowsMargin: rowsMargin,
				columnsCount: columnsCount,
				columnsMargin: columnsMargin
			});
			selection = selectedLayers;

			//make sure that grid creation was successful
			if(!selectedLayers) {
				return;
			}
		}

		//populate design with data
		populate(data, selectedLayers, {
			rootDir: rootDir,
			randomizeData: randomizeData,
			trimText: trimText,
			insertEllipsis: insertEllipsis,
			defaultSubstitute: defaultSubstitute
		});
	}
}


function populateAgainHandler(_context) {
	context = _context;

	//get defaults
	var defaults = [NSUserDefaults standardUserDefaults];

	//get selected layers
	var selectedLayers = Library.getSelectedLayers();
	selection = selectedLayers;
	if(!selectedLayers.length) {
		context.document.showMessage('Please select the layers you would like to populate.');
		return;
	}

	//get last used data path
	var lastDataPath = [defaults objectForKey: 'dataPath'];
	if(!lastDataPath) {
		context.document.showMessage('You must first use \'Populate with Preset\' or \'Populate with JSON\'.');
		return;
	}

	//get root dir
	var rootDir = [lastDataPath stringByDeletingLastPathComponent];

	//get options
	var randomizeData = Number([defaults objectForKey: 'randomizeData']);
	var trimText = Number([defaults objectForKey: 'trimText']);
	var insertEllipsis = Number([defaults objectForKey: 'insertEllipsis']);
	var defaultSubstitute = [defaults objectForKey: 'defaultSubstitute'];

	//check how last population was done
	var lastPopulateMethod = [defaults objectForKey: 'populateMethod'];

	//authorise rootDir if JSON method
	if(lastPopulateMethod == 'JSON') {
		if(!Sandbox.authoriseDir(rootDir)) return;
	}

	//load data
	var data = loadData(lastDataPath);

	//populate design with data
	populate(data, selectedLayers, {
		rootDir: rootDir,
		randomizeData: randomizeData,
		trimText: trimText,
		insertEllipsis: insertEllipsis,
		defaultSubstitute: defaultSubstitute
	});
}


function populate(data, selectedLayers, opt) {

	//keep track of already selected random indexes
	var randomIndexes = [];
	var lastRandomIndex = 0;

	//import state
	var numberOfSelectedLayers = selectedLayers.length;
	var currentLayerIndex = 0;
	var svgIconCount = 0;
	var svgIconsImported = 0;
	var svgIconsStartedImport = 0;

	//remove existing temp page
	var existingTempPage = Library.findPageWithName('__TEMP_DATA_POPULATOR__', true);
	if(existingTempPage) {
		var doc = context.document;
		doc.removePage(existingTempPage);
	}

	//prepare temporary page
	var tempIconPage = Library.addPage('__TEMP_DATA_POPULATOR__');

	//count svg icon placeholders in selection
	for(var i = 0; i < selectedLayers.length; i++) {
		var iconPlaceholders = Library.findLayersInLayer('{{*}}', false, 'MSShapeGroup', selectedLayers[i], false, false);
		svgIconCount += iconPlaceholders.length;
	}

	//populate population process
	populateSelection();


	function populateSelection() {

		//process each selected layer
		for(var i = 0; i < selectedLayers.length; i++) {
			currentLayerIndex = i;

			//get data row
			var dataRow;
			if(data instanceof Array) {
				if(opt.randomizeData) {

					//reset random index tracking
					if(randomIndexes.length == data.length) {
						randomIndexes = [];
					}

					//get random index
					var randomIndex;
					while(!randomIndex && randomIndex !== 0) {

						//get random in range
						var random = Library.randomInteger(0, data.length);

						//make sure index doesn't exist in already chosen random indexes
						if(randomIndexes.indexOf(random) == -1) {

							//make sure it's not the same as the last chosen random index
							if(data.length > 1) {
								if(random != lastRandomIndex) {
									randomIndex = random;
								}
							}
							else {
								randomIndex = random;
							}
						}
					}

					//store selected random index
					lastRandomIndex = randomIndex;
					randomIndexes.push(randomIndex);

					//get data row for random index
					dataRow = data[randomIndex];

					//reset random index (so next iteration generates a new one)
					randomIndex = null;
				}
				else {
					dataRow = data[i % data.length];
				}
			}
			else {
				dataRow = data;
			}

			//check type of selected layer
			var selectedLayer = selectedLayers[i];
			if(Library.isLayerGroup(selectedLayer)) {
				
				//get all selected artboards and process them
				var artboards = Library.findLayersInLayer(false, false, 'MSArtboardGroup', selectedLayer, false, false);
				artboards.forEach(function(artboard) {
					processArtboard(artboard, dataRow)
				});

				//get all text layers in selected layer
				var textLayers = Library.findLayersInLayer(false, false, 'MSTextLayer', selectedLayer, false, false);

				//process all text layers
				textLayers.forEach(function(textLayer) {
					processTextLayer(textLayer, dataRow);
				});

				//find icon and image placeholders
				var colorPlaceholders = Library.findLayersInLayer('{{{*}}}', false, 'MSShapeGroup', selectedLayer, false, false);
				var iconPlaceholders = Library.findLayersInLayer('{{*}}', false, 'MSShapeGroup', selectedLayer, false, colorPlaceholders);
				var imagePlaceholders = Library.findLayersInLayer('{*}', false, 'MSShapeGroup', selectedLayer, false, colorPlaceholders.concat(iconPlaceholders));

				//process all image placeholders
				imagePlaceholders.forEach(function(shapeGroup) {
					processImagePlaceholder(shapeGroup, dataRow, opt.rootDir);
				});

				//process all icon placeholders
				iconPlaceholders.forEach(function(shapeGroup) {
					processIconPlaceholder(shapeGroup, dataRow, opt.rootDir);
					svgIconsStartedImport++;
				});

				//process all color placeholders
				colorPlaceholders.forEach(function(shapeGroup) {
					processColorPlaceholder(shapeGroup, dataRow, opt.rootDir);
				});
			}
			else if(Library.isLayerText(selectedLayer)) {
				processTextLayer(selectedLayer, dataRow);
			}
			else if(Library.isLayerShapeGroup(selectedLayer)) {

				//check if image or icon placeholder
				if([selectedLayer name].indexOf('{{') > -1) {
					processIconPlaceholder(selectedLayer, dataRow, opt.rootDir);
				}
				else if([selectedLayer name].indexOf('{') > -1) {
					processImagePlaceholder(selectedLayer, dataRow, opt.rootDir);
				}
			}
			else if(Library.isArtboard(selectedLayer)) {
				processArtboard(selectedLayer, dataRow);
			}
		}

		//if there were no svg icons, processing is now finished
		if(svgIconCount == 0) {

			//remove temp page
			Library.removePage(tempIconPage);

			//select original layers
			restoreSelection();
		}
	}

	function findValueInDataRow(key, dataRow) {
		return _.get(dataRow, key);
	}

	function processTextLayer(textLayer, dataRow) {

		//reference command
		var command = context.command;

		//get stored text from layer
		var storedText = [command valueForKey: 'textWithPlaceholders' onLayer: textLayer];

		//get text from text layer
		var text;
		if(storedText && storedText.length) {
			text = storedText;
		}
		else {
			text = [textLayer stringValue];
		}

		//store text on layer
		[command setValue: String(text) forKey: 'textWithPlaceholders' onLayer: textLayer];

		//get placeholders in text
		var placeholders = getPlaceholders(text);

		//assign values to placeholders
		var values = {};
		placeholders.forEach(function(placeholder) {

			//solo/default placeholder
			if(placeholder.type == 'solo') {

				//get value
				var value = findValueInDataRow(placeholder.key, dataRow);

				//use substitute if value doesn't exist
				if(!value) {

					if(placeholder.substitute) {

						//use in-line substitute
						value = String(placeholder.substitute);
					}
					else {

						//use default substitute
						value = '';
					}
				}

				values[placeholder.string] = value;
			}
			else if(placeholder.type == 'enum') {

				//get values for sub placeholders
				var placeholderValues = [];
				placeholder.placeholders.forEach(function(subPlaceholder) {

					//get value
					var value = findValueInDataRow(subPlaceholder.key, dataRow);

					//use substitute if value doesn't exist
					if(!value) {

						if(subPlaceholder.substitute) {

							//use in-line substitute
							value = String(subPlaceholder.substitute);
						}
						else {

							//use default substitute
							value = '';
						}
					}

					//make sure value is not empty
					if(value.length) placeholderValues.push(value);
				});

				//prepare enumerated value
				var enumeratedValue = '';
				if(placeholder.command == 'join') {
					enumeratedValue = placeholderValues.join(placeholder.delimiter);
				}

				values[placeholder.string] = enumeratedValue;
			}
		});

		//merge text with values
		var mergedText = Library.mergeStringWithValues(text, values);

		//prevent bug with empty text layer
		if(!mergedText.length) {
			mergedText = '-';
			textLayer.setIsVisible(false);
		}
		else {
			textLayer.setIsVisible(true);
		}

		//set text layer text
		textLayer.setStringValue(mergedText);

		//resize text layer to fit text
		Library.refreshTextLayer(textLayer);

		//check if text layer has fixed size and trimming activated
		if(textLayer.textBehaviour() == 1 && opt.trimText) {

			//get original text layer height
			var textLayerFrame = textLayer.frame();
			var originalHeight = textLayerFrame.height();

			//resize to fit and get new height
			Library.resizeTextLayer(textLayer);
			var newHeight = textLayerFrame.height();

			//shorten text to fit
			var didTrim = (newHeight > originalHeight);
			while(newHeight > originalHeight) {

				//trim last character
				mergedText = mergedText.substring(0, mergedText.length - 1);

				//set trimmed text and re-evaluate height
				textLayer.setStringValue(mergedText);
				Library.resizeTextLayer(textLayer);
				newHeight = textLayerFrame.height();
			}

			//if trimmed add ellipsis
			if(didTrim && opt.insertEllipsis) {

				//add ellipsis
				mergedText += '…';
				textLayer.setStringValue(mergedText);
				Library.resizeTextLayer(textLayer);
				newHeight = textLayerFrame.height();

				//make sure that ellipsis fits in the text layer
				while(newHeight > originalHeight) {

					//remove character before ellipsis
					mergedText = mergedText.substring(0, mergedText.length - 2);
					mergedText += '…';

					//set new text with ellipsis
					textLayer.setStringValue(mergedText);
					Library.resizeTextLayer(textLayer);
					newHeight = textLayerFrame.height();
				}
			}
		}
		else {

			//resize to fit
			Library.resizeTextLayer(textLayer);
		}
	}


	function processArtboard(artboard, dataRow) {
		
		//reference command
		var command = context.command;

		//get stored text from artboard layer
		var storedText = [command valueForKey: 'textWithPlaceholders' onLayer: artboard];

		//get text from text layer
		var text;
		if(storedText && storedText.length) {
			text = storedText;
		}
		else {
			text = [artboard name];
		}

		//store text on layer
		[command setValue: String(text) forKey: 'textWithPlaceholders' onLayer: artboard];
		
		//get placeholders in text
		var placeholders = getPlaceholders(text);

		var values = {};
		placeholders.forEach(function(placeholder) {
			if(placeholder.type == 'solo') {
				var value = findValueInDataRow(placeholder.key, dataRow);

				if(!value) {
					if(placeholder.substitute) {
						value = String(placeholder.substitute);
					} else {
						value = '';
					}
				}

				values[placeholder.string] = value;
			}
			else if(placeholder.type == 'enum') {
				var placeholderValues = [];

				placeholder.placeholders.forEach(function(subPlaceholder) {
					var value = findValueInDataRow(subPlaceholder.key, dataRow);

					if(!value) {
						if(subPlaceholder.substitute) {
							value = String(subPlaceholder.substitute);
						} else {
							value = '';
						}
					}

					if(value.length) placeholderValues.push(value);
				});

				var enumeratedValue = '';
				if(placeholder.command == 'join') {
					enumeratedValue = placeholderValues.join(placeholder.delimiter);
				}

				values[placeholder.string] = enumeratedValue;
			}
		});

		var mergedText = Library.mergeStringWithValues(text, values);
		if(!mergedText.length) {
			mergedText = '-';
		}

		[artboard setName: mergedText];
	}


	function processImagePlaceholder(shapeGroup, dataRow, rootDir) {

		//get shape group name
		var shapeGroupName = [shapeGroup name].toString();

		//get placeholder name
		var placeholder = shapeGroupName.substring(1, [shapeGroupName length] - 1);

		//get image url for placeholder from data row
		var imageUrl = findValueInDataRow(placeholder, dataRow);
		if(!imageUrl) {

			//get shape group fill
			var fill = [[[shapeGroup style] fills] firstObject];

			//disable fill
			fill.setIsEnabled(false);

			return;
		}
		if(imageUrl[0] == '/') imageUrl = imageUrl.substring(1);

		//build full image url
		var fullImageUrl = [rootDir stringByAppendingPathComponent: imageUrl];

		//load image
		var fileManager = [NSFileManager defaultManager];
		if ([fileManager fileExistsAtPath: fullImageUrl]) {
			var image = [[NSImage alloc] initWithContentsOfFile: fullImageUrl];
			var imageData = [[MSImageData alloc] initWithImage: image convertColorSpace: false]];
			
			//get shape group fill
			var fill = [[[shapeGroup style] fills] firstObject];

			//enable fill
			fill.setIsEnabled(true);

			//set pattern fill
			fill.setFillType(4);
			[fill setImage: imageData];
			fill.setPatternFillType(1);
		}

		// Regular expression to match URL images
		var urlRegexp = new RegExp('(http)[s]?(://)');

		// Conditional test for image
		if (urlRegexp.test(imageUrl)) {
			var imageData = get(imageUrl);

			var image = [[NSImage alloc] initWithData: imageData];

			//get shape group fill
			var fill = [[[shapeGroup style] fills] firstObject];

			//enable fill
			fill.setIsEnabled(true);

			//set pattern fill
			fill.setFillType(4);

			//set image as pattern fill
			var imageCollection = fill.documentData().images();
			[fill setPatternImage: image collection: imageCollection];
			fill.setPatternFillType(1);
		}
	}


	function processIconPlaceholder(shapeGroup, dataRow, rootDir) {

		//get shape group name
		var shapeGroupName = [shapeGroup name].toString();

		//get placeholder name
		var placeholder = shapeGroupName.substring(2, [shapeGroupName length] - 2);

		//get icon url for placeholder from data row
		var iconUrl = findValueInDataRow(placeholder, dataRow);
		if(!iconUrl) {
			svgIconsImported++;

			//hide placeholder
			shapeGroup.setIsVisible(false);

			//check if all icons for selection are imported now
			if(svgIconsImported == svgIconCount) {

				//remove temp page
				Library.removePage(tempIconPage);

				//select original layers
				restoreSelection();
			}

			return;
		}
		else {

			//show placeholder
			shapeGroup.setIsVisible(true);
		}
		if(iconUrl[0] == '/') iconUrl = iconUrl.substring(1);

		//build full icon url
		var fullIconUrl = [rootDir stringByAppendingPathComponent: iconUrl];

		//import icon
		var fileManager = [NSFileManager defaultManager];
		if ([fileManager fileExistsAtPath: fullIconUrl]) {

			//get original placeholder icon frame
			var placeholderFrame = {
				x: shapeGroup.frame().x(),
				y: shapeGroup.frame().y(),
				width: shapeGroup.frame().width(),
				height: shapeGroup.frame().height()
			};

			//get shape group layers
			var placeholderSubLayers = Library.jsArray([shapeGroup layers]);

			//get file NSURL
			var fileUrl = [NSURL fileURLWithPath:fullIconUrl];

			//set up importer
			var SVGImporter = [MSSVGImporter svgImporter];

			//create temporary group for import
			var container = tempIconPage.addLayerOfType('group');
			container.setName('__IMPORTED_SVG__');

			//import svg into the container
			[MSDocumentImporter importFromURL: fileUrl inGroup: container importer: SVGImporter];
			
			//continue after delay to make sure import is complete
			Library.delay(function() {
				attemptImport();
			}, 0.01);


			function attemptImport() {

				//get container layers
				var containerLayers = Library.jsArray([container layers]);

				//there should only ever be one layer inside the container
				if(containerLayers.length >= 1) {

					//get layer
					var layer = containerLayers[0];

					//layer is a single shape group
					if([layer isKindOfClass: [MSShapeGroup class]]) {

						//get shape group layers
						var subLayers = Library.jsArray([layer layers]);

						//remove sub layers from imported shape group
						subLayers.forEach(function(subLayer) {
							subLayer.removeFromParent();
						});

						//add sub layers to original shape group
						shapeGroup.addLayers(subLayers);
					}

					//layer is a layer group containing more layers
					if([layer isKindOfClass: [MSLayerGroup class]] && ![layer isKindOfClass: [MSShapeGroup class]]) {

						//get group layers
						var subLayers = Library.jsArray([layer layers]);

						//create root shape
						var rootShape = [[MSShapeGroup alloc] init];

						//merge layers using union boolean operation
						[MSBooleanOperations mergeShapes:subLayers withShape:rootShape usingBooleanOp: 3];

						//get union shape group layers
						var unionSubLayers = Library.jsArray([rootShape layers]);

						//remove sub layers from imported shape group
						unionSubLayers.forEach(function(unionedSubLayer) {
							unionedSubLayer.removeFromParent();
						});

						//add sub layers to original shape group
						shapeGroup.addLayers(unionSubLayers);
					}

					//delete original placeholder sub layers from shape group
					placeholderSubLayers.forEach(function(placeholderSubLayer) {
						placeholderSubLayer.removeFromParent();
					});

					//get imported icon size
					var iconFrame = {
						x: shapeGroup.frame().x(),
						y: shapeGroup.frame().y(),
						width: shapeGroup.frame().width(),
						height: shapeGroup.frame().height()
					};

					//configure final frame
					var finalFrame = Library.scaleToBoundingBox(placeholderFrame, iconFrame, true);

					//set shape group frame
					shapeGroup.frame().setX(finalFrame.x);
					shapeGroup.frame().setY(finalFrame.y);
					shapeGroup.frame().setWidth(finalFrame.width);
					shapeGroup.frame().setHeight(finalFrame.height);

					//remove container
					container.removeFromParent();

					//count the imported icon
					svgIconsImported++;

					//check if all icons for selection are imported now
					if(svgIconsImported == svgIconCount) {

						//remove temp page
						Library.removePage(tempIconPage);

						//select original layers
						restoreSelection();
					}
				}
				else {

					//try again later
					Library.delay(function() {
						attemptImport();
					}, 0.01);
				}
			}
		}
		else {
			svgIconsImported++;
		}
	}

	function processColorPlaceholder(shapeGroup, dataRow, rootDir) {

		//get shape group name
		var shapeGroupName = [shapeGroup name].toString();

		//get placeholder name
		var placeholder = shapeGroupName.substring(3, [shapeGroupName length] - 3);

		//get hex color for placeholder from data row
		var hexColor = dataRow[placeholder];

		if(!hexColor) {
			
			//hide placeholder
			shapeGroup.setIsVisible(false);
			return;
		}
		else {
			
			//show placeholder
			shapeGroup.setIsVisible(true);
		}

		//get shape group fill
		var fill = [[[shapeGroup style] fills] firstObject];

		//enable fill
		fill.setIsEnabled(true);

		//set pattern fill
		fill.setFillType(0);

		// set the color
		fill.color = [MSColor colorWithSVGString:hexColor];
	}


	function getPlaceholders(str) {

		//collect placeholders
		var results = [];

		//regex matching
		var re = /{([^}]+)}/g;
		var text;

		//find placeholders
		while(text = re.exec(str)) {

			//get inside of placeholder (between {})
			var placeholderText = text[1];

			//check if placeholder uses enumeration syntax
			if(placeholderText.indexOf('|&') > -1) {

				//split enum placeholder text into components
				var placeholderComponents = placeholderText.split('|&');

				//get placeholders
				var placeholdersString = placeholderComponents[0] || '';
				var placeholderStrings = placeholdersString.split(',');
				var placeholders = [];
				placeholderStrings.forEach(function(placeholderString) {

					//process placeholder string
					var placeholder = processPlaceholderString(placeholderString.trim());
					placeholders.push(placeholder);
				});

				//get delimiter
				var delimiter = placeholderComponents[1] || '';

				//create object
				results.push({
					string: placeholderText,
					type: 'enum',
					command: 'join',
					delimiter: delimiter,
					placeholders: placeholders
				});
			}
			else {

				//process placeholder text
				var placeholder = processPlaceholderString(placeholderText);
				results.push(placeholder);
			}
		}


		function processPlaceholderString(placeholderString) {

			//split into components
			var placeholderComponents = placeholderString.split('?');

			//check if has substitute
			var hasSubstitute = (placeholderComponents.length == 2);
			if(hasSubstitute) {

				//get key and substitute
				var key = placeholderComponents[0].trim();
				var substitute = placeholderComponents[1].trim();

				//set default substitute
				if(!substitute.length) substitute = opt.defaultSubstitute;

				return {
					type: 'solo',
					string: placeholderString,
					key: key,
					substitute: substitute
				};
			}
			else {

				return {
					type: 'solo',
					string: placeholderString,
					key: placeholderString
				};
			}
		}

		return results;
	}
}


function createGrid(selectedLayers, opt) {

	//check rows count
	if(!opt.rowsCount || opt.rowsCount < 0) {
		context.document.showMessage('Number of grid rows must be at least 1.');
		return;
	}

	//check rows margin
	if((!opt.rowsMargin && opt.rowsMargin != 0) || opt.rowsMargin < 0) {
		context.document.showMessage('Grid row margin is invalid.');
		return;
	}

	//check column count
	if(!opt.columnsCount || opt.columnsCount < 0) {
		context.document.showMessage('Number of grid columns must be at least 1.');
		return;
	}

	//check columns margin
	if((!opt.columnsMargin && opt.columnsMargin != 0) || opt.columnsMargin < 0) {
		context.document.showMessage('Grid column margin is invalid.');
		return;
	}

	//get first layer (most top left)
	var layer = selectedLayers[0];
	var smallestX = selectedLayers[0].frame().x();
	var smallestY = selectedLayers[0].frame().y();
	for(var i = 0; i < selectedLayers.length; i++) {
		var tempLayer = selectedLayers[i];
		if(tempLayer.frame().x() < smallestX || tempLayer.frame().y() < smallestY) {
			smallestX = tempLayer.frame().x();
			smallestY = tempLayer.frame().y();
			layer = tempLayer;
		}
	}

	//arrange copies of the first layer
	var layerWidth = layer.frame().width();
	var layerHeight = layer.frame().height();
	var layerParent = [layer parentGroup];
	if(!layerParent) layerParent = [layer parentArtboard];
	if(!layerParent) layerParent = [layer parentPage];

	//remove selected layers from parent
	selectedLayers.forEach(function(tempLayer) {
		tempLayer.removeFromParent();
	});

	//keep track of original position
	var startX = layer.frame().x();
	var startY = layer.frame().y();

	//store new selected layers
	var newSelectedLayers = [];

	//create rows
	for(var i = 0; i < opt.rowsCount; i++) {

		//set row y
		var y = startY + (i * (layerHeight + opt.rowsMargin));

		//create columns
		for(var j = 0; j < opt.columnsCount; j++) {

			//create layer copy
			var copy = Library.copyLayer(layer);

			//add to parent layer
			layerParent.addLayers([copy]);

			//add to selected layers
			newSelectedLayers.push(copy);

			//set column x
			var x = startX + (j * (layerWidth + opt.columnsMargin));

			//position copy
			copy.frame().setX(x);
			copy.frame().setY(y);
		}
	}

	return newSelectedLayers;
}


function createDataOptionsView() {

	//create options view
	var optionsView = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 110)];

	//create options view title
	var optionsViewTitle = Library.createLabel('Data options', 12, true, NSMakeRect(0, 90, 300, 20));
	[optionsView addSubview: optionsViewTitle];

	//create randomize checkbox
	var randomizeCheckbox = Library.createCheckbox('Randomize data order', false, NSMakeRect(0, 65, 300, 20));
	[optionsView addSubview: randomizeCheckbox];

	//set randomize checkbox state
	[randomizeCheckbox setState: [[NSUserDefaults standardUserDefaults] objectForKey:'randomizeData']];

	//create trim checkbox
	var trimCheckbox = Library.createCheckbox('Trim overflowing text (fixed width text layers)', false, NSMakeRect(0, 45, 300, 20));
	[optionsView addSubview: trimCheckbox];

	//set trim checkbox state
	[trimCheckbox setState: [[NSUserDefaults standardUserDefaults] objectForKey:'trimText']];

	//create ellipsis checkbox
	var ellipsisCheckbox = Library.createCheckbox('Insert ellipsis after trimmed text', false, NSMakeRect(0, 25, 300, 20));
	[optionsView addSubview: ellipsisCheckbox];

	//set ellipsis checkbox state
	[ellipsisCheckbox setState: [[NSUserDefaults standardUserDefaults] objectForKey:'insertEllipsis']];

	//create substitute label
	var substituteLabel = Library.createLabel('Default substitute:', 12, false, NSMakeRect(0, 0, 110, 20));
	[optionsView addSubview: substituteLabel];

	//create substitute text field
	var substituteTextField = [[NSTextField alloc] initWithFrame:NSMakeRect(110, 0, 120, 22)];
	[optionsView addSubview: substituteTextField];

	//set substitute
	if([[NSUserDefaults standardUserDefaults] objectForKey:'defaultSubstitute']) {
		[substituteTextField setStringValue:[[NSUserDefaults standardUserDefaults] objectForKey:'defaultSubstitute']];
	}
	else {
		[substituteTextField setStringValue:''];
	}


	//return configured view
	return {
		view: optionsView,
		randomizeCheckbox: randomizeCheckbox,
		trimCheckbox: trimCheckbox,
		ellipsisCheckbox: ellipsisCheckbox,
		substituteTextField: substituteTextField
	};
}


function createLayoutOptionsView() {

	//create options view
	var optionsView = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 104)];

	//create options view title
	var optionsViewTitle = Library.createLabel('Layout options', 12, true, NSMakeRect(0, 84, 300, 20));
	[optionsView addSubview: optionsViewTitle];

	//create create grid checkbox
	var createGridCheckbox = Library.createCheckbox('Create grid', false, NSMakeRect(0, 59, 300, 20));
	[optionsView addSubview: createGridCheckbox];

	//set randomize checkbox state
	[createGridCheckbox setState: [[NSUserDefaults standardUserDefaults] objectForKey:'createGrid']];



	//create rows count label
	var rowsCountLabel = Library.createLabel('Rows:', 12, false, NSMakeRect(0, 27, 60, 20));
	[optionsView addSubview: rowsCountLabel];

	//create rows count text field
	var rowsCountTextField = [[NSTextField alloc] initWithFrame:NSMakeRect(60, 27, 70, 22)];
	[optionsView addSubview: rowsCountTextField];

	//set rows count
	if([[NSUserDefaults standardUserDefaults] objectForKey:'rowsCount']) {
		[rowsCountTextField setStringValue:[[NSUserDefaults standardUserDefaults] objectForKey:'rowsCount']];
	}
	else {
		[rowsCountTextField setStringValue:'1'];
	}


	//create rows margin label
	var rowsMarginLabel = Library.createLabel('Margin:', 12, false, NSMakeRect(142, 27, 50, 20));
	[optionsView addSubview: rowsMarginLabel];

	//create rows margin text field
	var rowsMarginTextField = [[NSTextField alloc] initWithFrame:NSMakeRect(190, 27, 70, 22)];
	[optionsView addSubview: rowsMarginTextField];

	//set rows margin
	if([[NSUserDefaults standardUserDefaults] objectForKey:'rowsMargin']) {
		[rowsMarginTextField setStringValue:[[NSUserDefaults standardUserDefaults] objectForKey:'rowsMargin']];
	}
	else {
		[rowsMarginTextField setStringValue:'10'];
	}


	//create columns count label
	var columnsCountLabel = Library.createLabel('Columns:', 12, false, NSMakeRect(0, 0, 60, 20));
	[optionsView addSubview: columnsCountLabel];

	//create columns count text field
	var columnsCountTextField = [[NSTextField alloc] initWithFrame:NSMakeRect(60, 0, 70, 22)];
	[optionsView addSubview: columnsCountTextField];

	//set columns count
	if([[NSUserDefaults standardUserDefaults] objectForKey:'columnsCount']) {
		[columnsCountTextField setStringValue:[[NSUserDefaults standardUserDefaults] objectForKey:'columnsCount']];
	}
	else {
		[columnsCountTextField setStringValue:'1'];
	}

	//create columns margin label
	var columnsMarginLabel = Library.createLabel('Margin:', 12, false, NSMakeRect(142, 0, 50, 20));
	[optionsView addSubview: columnsMarginLabel];

	//create columns margin text field
	var columnsMarginTextField = [[NSTextField alloc] initWithFrame:NSMakeRect(190, 0, 70, 22)];
	[optionsView addSubview: columnsMarginTextField];


	//set columns margin
	if([[NSUserDefaults standardUserDefaults] objectForKey:'columnsMargin']) {
		[columnsMarginTextField setStringValue:[[NSUserDefaults standardUserDefaults] objectForKey:'columnsMargin']];
	}
	else {
		[columnsMarginTextField setStringValue:'10'];
	}

	//return configured view
	return {
		view: optionsView,
		createGridCheckbox: createGridCheckbox,
		rowsCountTextField: rowsCountTextField,
		rowsMarginTextField: rowsMarginTextField,
		columnsCountTextField: columnsCountTextField,
		columnsMarginTextField: columnsMarginTextField
	};
}


function loadData(path) {

	//load contents
	var contents = Library.readFileAsText(path);

	//get data from JSON
	var data;
	try {
		data = JSON.parse(contents);
	}
	catch(e) {
		context.document.showMessage("There was an error parsing data. Please make sure it's valid.");
		return;
	}

	return data;
}


//===============================================


function revealPresetsHandler(_context) {

	//assing global context reference
	context = _context;

	//get presets dir
	var presetDir = Library.getPresetsDir();

	//open dir
	var url = [NSURL fileURLWithPath: presetDir];
	[[NSWorkspace sharedWorkspace] openURL: url];
}


//===============================================


function restoreSelection() {

	//deselect current selection
	var doc = context.document;
	[[doc currentPage] deselectAllLayers];

	selection.forEach(function(layer) {
		[layer select:true byExpandingSelection:true];
	});
}


function insertImageHandler(_context) {
	context = _context;
	var doc = context.document;

	//get selection
	var selection = Library.getSelectedLayers();
	if(selection.length == 1) {
		var layer = selection[0];

		//make sure it's a shape group
		if(Library.isLayerShapeGroup(layer)) {

			//get last used location
			var defaults = [NSUserDefaults standardUserDefaults];
			var lastLocation = [defaults objectForKey: 'LastImageFilePickerLocation'];

			//ask for image
			var imageUrl = Library.askForImage(lastLocation);
			if(!imageUrl) return;

			//save last used location
			[defaults setObject: imageUrl forKey: 'LastImageFilePickerLocation'];
			[defaults synchronize];

			//load image
			var fileManager = [NSFileManager defaultManager];
			if ([fileManager fileExistsAtPath: imageUrl]) {
				var image = [[NSImage alloc] initWithContentsOfFile: imageUrl];

				//get shape group fill
				var fill = [[[layer style] fills] firstObject];

				//set pattern fill
				fill.setFillType(4);

				//set image as pattern fill
				var imageCollection = fill.documentData().images();
				[fill setPatternImage: image collection: imageCollection];
				fill.setPatternFillType(1);
			}

		}
		else {
			[doc showMessage: 'The selected layer is not a shape layer.'];
		}
	}
	else {
		[doc showMessage: 'Please select a single shape layer.'];
	}
}


function insertSVGHandler(_context) {
	context = _context;
	var doc = context.document;

	//get selection
	var selection = Library.getSelectedLayers();
	if(selection.length == 1) {
		var shapeGroup = selection[0];

		//make sure it's a shape group
		if(Library.isLayerShapeGroup(shapeGroup)) {

			//get last used location
			var defaults = [NSUserDefaults standardUserDefaults];
			var lastLocation = [defaults objectForKey: 'LastSVGFilePickerLocation'];

			//ask for image
			var svgUrl = Library.askForSVG(lastLocation);
			if(!svgUrl) return;

			//save last used location
			[defaults setObject: svgUrl forKey: 'LastSVGFilePickerLocation'];
			[defaults synchronize];

			//load image
			var fileManager = [NSFileManager defaultManager];
			if ([fileManager fileExistsAtPath: svgUrl]) {

				//remove existing temp page
				var existingTempPage = Library.findPageWithName('__TEMP_DATA_POPULATOR__', true);
				if(existingTempPage) {
					doc.removePage(existingTempPage);
				}

				//prepare temporary page
				var tempIconPage = Library.addPage('__TEMP_DATA_POPULATOR__');

				//get original placeholder icon frame
				var placeholderFrame = {
					x: shapeGroup.frame().x(),
					y: shapeGroup.frame().y(),
					width: shapeGroup.frame().width(),
					height: shapeGroup.frame().height()
				};

				//get shape group layers
				var placeholderSubLayers = Library.jsArray([shapeGroup layers]);

				//get file NSURL
				var fileUrl = [NSURL fileURLWithPath:svgUrl];

				//set up importer
				var SVGImporter = [MSSVGImporter svgImporter];

				//create temporary group for import
				var container = tempIconPage.addLayerOfType('group');
				container.setName('__IMPORTED_SVG__');

				//import svg into the container
				[MSDocumentImporter importFromURL: fileUrl inGroup: container importer: SVGImporter];

				//continue after delay to make sure import is complete
				Library.delay(function() {
					attemptImport();
				}, 0.01);


				function attemptImport() {

					//get container layers
					var containerLayers = Library.jsArray([container layers]);

					//there should only ever be one layer inside the container
					if(containerLayers.length >= 1) {

						//get layer
						var layer = containerLayers[0];

						//layer is a single shape group
						if([layer isKindOfClass: [MSShapeGroup class]]) {

							//get shape group layers
							var subLayers = Library.jsArray([layer layers]);

							//remove sub layers from imported shape group
							subLayers.forEach(function(subLayer) {
								subLayer.removeFromParent();
							});

							//add sub layers to original shape group
							shapeGroup.addLayers(subLayers);
						}

						//layer is a layer group containing more layers
						if([layer isKindOfClass: [MSLayerGroup class]] && ![layer isKindOfClass: [MSShapeGroup class]]) {

							//get group layers
							var subLayers = Library.jsArray([layer layers]);

							//create root shape
							var rootShape = [[MSShapeGroup alloc] init];

							//merge layers using union boolean operation
							[MSBooleanOperations mergeShapes:subLayers withShape:rootShape usingBooleanOp: 3];

							//get union shape group layers
							var unionSubLayers = Library.jsArray([rootShape layers]);

							//remove sub layers from imported shape group
							unionSubLayers.forEach(function(unionedSubLayer) {
								unionedSubLayer.removeFromParent();
							});

							//add sub layers to original shape group
							shapeGroup.addLayers(unionSubLayers);
						}

						//delete original placeholder sub layers from shape group
						placeholderSubLayers.forEach(function(placeholderSubLayer) {
							placeholderSubLayer.removeFromParent();
						});

						//get imported icon size
						var iconFrame = {
							x: shapeGroup.frame().x(),
							y: shapeGroup.frame().y(),
							width: shapeGroup.frame().width(),
							height: shapeGroup.frame().height()
						};

						//configure final frame
						var finalFrame = Library.scaleToBoundingBox(placeholderFrame, iconFrame, true);

						//set shape group frame
						shapeGroup.frame().setX(finalFrame.x);
						shapeGroup.frame().setY(finalFrame.y);
						shapeGroup.frame().setWidth(finalFrame.width);
						shapeGroup.frame().setHeight(finalFrame.height);

						//remove container
						container.removeFromParent();

						//remove temp page
						doc.removePage(tempIconPage);
					}
					else {

						//try again later
						Library.delay(function() {
							attemptImport();
						}, 0.01);
					}
				}
			}
		}
		else {
			[doc showMessage: 'The selected layer is not a shape layer.'];
		}
	}
	else {
		[doc showMessage: 'Please select a single shape layer.'];
	}
}


//===============================================


function restoreTextPlaceholdersHandler(_context) {
	context = _context;
	var doc = context.document;
	var command = context.command;

	//get selected layers
	var selectedLayers = Library.getSelectedLayers();
	selection = selectedLayers;
	if(!selectedLayers.length) {
		context.document.showMessage('Please select the text layers you would like to restore.');
		return;
	}

	//get all text layers and artboards in selection
	var textLayers = [];
	var artboards = [];
	selectedLayers.forEach(function(layer) {
		
		//add artboards too
		if(Library.isArtboard(layer)) {
			artboards.push(layer);
		}
		
		//get text layers from group
		else if(Library.isLayerGroup(layer)) {
			var nestedTextLayers = Library.findLayersInLayer(false, false, 'MSTextLayer', layer, false, false);
			textLayers = textLayers.concat(nestedTextLayers);
		}

		//add text layer
		else if(Library.isLayerText(layer)) {
			textLayers.push(layer);
		}
	});

	//restore text layers
	textLayers.forEach(function(textLayer) {

		//get stored text from layer
		var storedText = [command valueForKey: 'textWithPlaceholders' onLayer: textLayer];

		//replace text by original string including placeholders
		if(storedText) {

			//set text layer text
			textLayer.setStringValue(storedText);

			//resize text layer to fit text
			Library.refreshTextLayer(textLayer);
		}

		//remove text stored on layer
		[command setValue: nil forKey: 'textWithPlaceholders' onLayer: textLayer];
	});
	
	//restore artboard names
	artboards.forEach(function(artboardLayer) {
		
		//get stored text from layer
		var storedText = [command valueForKey: 'textWithPlaceholders' onLayer: artboardLayer];

		//replace text by original string including placeholders
		if(storedText) {

			//set text layer text
			artboardLayer.setName(storedText);
		}

		//remove text stored on layer
		[command setValue: nil forKey: 'textWithPlaceholders' onLayer: artboardLayer];
	})
}

function get(url) {
	var request = NSURLRequest.requestWithURL(NSURL.URLWithString(url));
	var response = NSURLConnection.sendSynchronousRequest_returningResponse_error(request, null, null);
	return response;
}
